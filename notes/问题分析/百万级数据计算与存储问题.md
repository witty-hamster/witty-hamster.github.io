
> 大体过程：BOM的逆向展阶拆解 ==> 生成中间逆向展阶表 ==> 生成最终适配表（用于体现每个零件在每个成品下具体是什么时间范围内有效）

## 前置信息
1. BOM逆向展阶计算后获得的数据量基本上在 350万条以上
2. 最终表获得的数据量基本上在220万条以上
3. 两个中间对象分别如下
```java
/**  
 * MBOM逆向展阶计算结果传输对象  
 *  
 * @author hamster * @date 2025/12/30 15:05 */@Data  
public class MbomReverseExplosionDTO {  
  
    /**  
     * 唯一ID  
     */    private Long id;  
  
    /**  
     * 叶子品号（如 C）  
     */  
    private String leafCode;  
  
    /**  
     * 叶子名称  
     */  
    private String leafName;  
  
    /**  
     * 叶子规格  
     */  
    private String leafSpecs;  
  
    /**  
     * 从顶层到子件的完整路径，如 ["A", "B", "C"]，正向展开存储  
     */  
    private List<String> fullPath;  
  
    /**  
     * 路径层级数（0=直接使用，2=A->B->C）  
     */  
    private Integer levelCount;  
  
    /**  
     * 顶层品号（如 A）  
     */  
    private String topCode;  
  
    /**  
     * 顶层品名  
     */  
    private String topName;  
  
    /**  
     * 顶层规格  
     */  
    private String topSpecs;  
  
    /**  
     * 顶层车型  
     */  
    private String topVehicle;  
  
    /**  
     * 次顶层品号  
     */  
    private String subTopCode;  
  
    /**  
     * 路径最早生效时间  
     */  
    private LocalDate effectiveFrom;  
  
    /**  
     * 路径最晚失效时间  
     */  
    private LocalDate effectiveTo;  
  
    /**  
     * 各层级生效信息，格式：[{"bom_id": "BOM-A", "from": "...", "to": "..."}, ...]  
     */    private List<MbomReverseExplosionDTO.TimeRange> layerEffectiveInfo;  
  
    /**  
     * 路径中涉及的所有 BOM ID，如 ["BOM-A", "BOM-B"]  
     */    private List<Long> sourceBomIds;  
  
    @Data  
    @NoArgsConstructor    @AllArgsConstructor    public static class TimeRange {  
        private LocalDate from;  
        private LocalDate to;  
  
        /**  
         * 计算路径整体有效时间（取所有层级生效时间的交集）  
         */  
        public static MbomReverseExplosionDTO.TimeRange calcPathTime(List<MbomReverseExplosionDTO.TimeRange> ranges) {  
            // 取出最大的生效时间  
            LocalDate from = ranges.stream()  
                    .map(r -> r.from)  
                    .max(LocalDate::compareTo)  
                    .orElse(null);  
            // 取出最小的失效时间  
            LocalDate to = ranges.stream()  
                    .map(r -> r.to)  
                    .filter(Objects::nonNull)  
                    .min(LocalDate::compareTo)  
                    .orElse(null);  
            return new MbomReverseExplosionDTO.TimeRange(from, to);  
        }  
    }  
}
```

## 第一版方案：逆向展阶 + 上传OSS + 存储DB
### 功能实现过程描述：
1. 先将BOM头信息 + BOM体信息全量的加载到内存中（其中，BOM头信息有 21749 行记录，BOM体信息有385447行记录）
2. 然后针对BOM数据做前置的映射处理，解决快速通过某一唯一标识，来定位获取相关数据（主要映射为Map结构）
3. 使用递归模型，先进行正向展阶递归，再进行反向封装处理，生成BOM逆向展阶结果集
4. 获取到逆向展阶结果集后，基于改结果集，进一步计算出每个零件在指定时间下（也就是计算当天）零件与成品之间的生效、失效、待生效等状态，生成一个适配与csv文件格式的List结构
5. 当前面所有的计算过程均执行完成后，将会针对BOM逆向展阶结果集进行处理，用这个结果集数据，生成中间表信息（主要的处理手段是多线程并发形式将数据以csv格式写入到系统的临时目录中，在上传到指定的OSS路径下）
6. 当第5步的文件生成与上传结束后，将使用串行方式，通过oceanbase的load data旁路导入模式，基于OSS上的文件，快速实现数据落盘，从而实现中间表数据的存储
7. 当中间表数据存储完毕后，将针对第4步得到的csv文件格式的List结构数据进行处理，该数据主要用于最终表的数据获取（主要的处理手段是多线程并发形式将数据写入到系统的临时目录，在上传到指定的OSS路径下）
8. 当第7步的文件生成与上传结束后，将使用串行方式，通过oceanbase的load data旁路导入模式，基于OSS上的文件，快速实现数据落盘，从而实现最终表数据的存储

### 代码部分
- 业务主入口
```java
public CommonResult<Void> mbomReverseCalcAndStorageV2() {  
    log.info("异步化执行处理 MBOM逆向展阶计算存储、最终表生成（第二版）... ...");  
    long startTime = System.currentTimeMillis();  
    CompletableFuture  
            .supplyAsync(() -> {  
                // 计算MBOM逆向展阶结果  
                List<MbomReverseExplosionDTO> calcResultList = mbomCalcAndStorageService.calculateReverseExplosion();  
                System.out.println("calcResultList: " + calcResultList.size());  
                // 计算MBOM最终表 - 零件适用车型结果  
                List<String> calcFinalResultList = mbomCalcAndStorageService.calculateFinalPartApplicability(calcResultList);  
                System.out.println("calcFinalResultList: " + calcFinalResultList.size());  
                // 入库中间表  
                Long loadMiddleCount = mbomCalcAndStorageService.generateMiddleCsvAndLoadData(calcResultList);  
                System.out.println("loadMiddleCount: " + loadMiddleCount);  
                // 入库最终表  
                Long loadFinalCount = mbomCalcAndStorageService.generateFinalCsvAndLoadData(calcFinalResultList);  
                System.out.println("loadFinalCount: " + loadFinalCount);  
                return null;  
            })  
            .exceptionally(ex -> {  
                log.error("异步化执行处理 MBOM逆向展阶计算存储、最终表生成过程发生异常... ... 原因: ", ex);  
                return null;  
            })  
            .whenComplete((res, ex) -> {  
                long duration = System.currentTimeMillis() - startTime;  
                log.info("所有任务均已执行完毕，共计耗时 {} ms", duration);  
            });  
    return CommonResult.success("任务执行中... ...");  
}
```

- 核心业务逻辑代码
```java
public interface MbomCalcAndStorageService {  
  
    /**  
     * 计算MBOM逆向展阶  
     *  
     * @return 计算结果  
     */  
    List<MbomReverseExplosionDTO> calculateReverseExplosion();  
  
    /**  
     * 计算最终的零件适用信息  
     *  
     * @param calcReverseList MBOM逆向展阶结果  
     * @return 计算结果  
     */  
    List<String> calculateFinalPartApplicability(List<MbomReverseExplosionDTO> calcReverseList);  
  
    /**  
     * 生成中间表CSV文件并使用旁路导入将数据导入数据库  
     *  
     * @param calcReverseList MBOM逆向展阶结果  
     * @return 导入结果  
     */  
    Long generateMiddleCsvAndLoadData(List<MbomReverseExplosionDTO> calcReverseList);  
  
    /**  
     * 生成最终表CSV文件并使用旁路导入将数据导入数据库  
     *  
     * @param csvContentList 最终表CSV内容体  
     * @return 导入结果  
     */  
    Long generateFinalCsvAndLoadData(List<String> csvContentList);  
  
}
```

```java
@Service  
public class MbomCalcAndStorageServiceImpl implements MbomCalcAndStorageService {  
  
    @Autowired  
    @Qualifier("computePool")  
    private Executor computePool;  
    @Autowired  
    @Qualifier("ioPool")  
    private Executor ioPool;  
    @Autowired  
    private SnowflakeIdWorker snowflakeIdWorker;  
    @Autowired  
    private AliyunOssService aliyunOssService;  
  
    @Autowired  
    private ErpMbomHeaderMapper erpMbomHeaderMapper;  
    @Autowired  
    private ErpMbomLineMapper erpMbomLineMapper;  
  
    @Autowired  
    private MdmMesVehicleOfflineService mdmMesVehicleOfflineService;  
    @Autowired  
    private TmpMbomReverseExplosionService tmpMbomReverseExplosionService;  
    @Autowired  
    private MbomPartTopApplicabilityService mbomPartTopApplicabilityService;
  
  
    @Override  
    public List<MbomReverseExplosionDTO> calculateReverseExplosion() {  
        log.info(">>>>>>>> 开始执行MBOM逆向展阶计算 (优化版) ... ...");  
        // 获取MBOM Header  
        List<MbomHeaderForExplosionPO> headers = erpMbomHeaderMapper.selectHeadersForExplosion();  
        if (CollectionUtils.isEmpty(headers)) {  
            return Collections.emptyList();  
        }  
        // 使用ioPool线程池，并行读取明细  
        List<Long> headerIds = headers.stream().map(MbomHeaderForExplosionPO::getId).distinct().collect(Collectors.toList());  
        List<List<Long>> headerIdPartitions = CollectionUtils.partitionIntoN(headerIds, SystemConstants.CPU_CORE_NUMBER);  
        List<CompletableFuture<List<MbomLineForExplosionPO>>> lineFutures = headerIdPartitions.stream()  
                .map(p -> CompletableFuture.supplyAsync(() ->  
                        erpMbomLineMapper.selectLinesForExplosionBatchHeaderIds(p), ioPool))  
                .collect(Collectors.toList());  
        // 等待所有数据查询完毕  
        List<MbomLineForExplosionPO> lines = lineFutures.stream()  
                .map(CompletableFuture::join)  
                .filter(Objects::nonNull)  
                .flatMap(List::stream)  
                .collect(Collectors.toList());  
        if (CollectionUtils.isEmpty(lines)) {  
            return Collections.emptyList();  
        }  
        // 构建内存映射（主件ID -> bom明细行）  
        Map<Long, List<MbomLineForExplosionPO>> headerToLineMapping = lines.stream()  
                .collect(Collectors.groupingBy(MbomLineForExplosionPO::getHeaderId));  
        // 构建内存映射（主件ID -> bom头）  
        Map<String, MbomHeaderForExplosionPO> headerMaterialMapping = headers.stream()  
                .collect(Collectors.toMap(MbomHeaderForExplosionPO::getProductCode,  
                        Function.identity(), (v1, v2) -> v1));  
        log.info(">>>>>>>> MBOM逆向展阶计算 (优化版) - 读取到 {} 条MBOM头，对应 {} 条明细，" +  
                        "构建出 {} 条主件ID->bom明细行映射关系，构建出 {} 条主件品号->bom头映射关系 ... ...",  
                headers.size(), lines.size(), headerToLineMapping.size(), headerMaterialMapping.size());  
  
        // 递归计算（CPU密集型）  
        List<MbomReverseExplosionDTO> resultList = Collections.synchronizedList(new ArrayList<>());  
        CompletableFuture.allOf(headers.stream().map(h -> CompletableFuture.runAsync(() -> {  
            // 执行递归逻辑 --> 生成计算结果  
            handleReverseExplosion(h, headerToLineMapping, headerMaterialMapping, resultList);  
        }, computePool)).toArray(CompletableFuture[]::new)).join();  
        return resultList;  
    }  
  
    /**  
     * 递归计算逆向展阶结果  
     *  
     * @param header                MBOM 头信息  
     * @param headerToLineMapping   MBOM明细行  
     * @param headerMaterialMapping 顶层主件物料映射（主件ID -> 主件MBOM Header）  
     * @param resultList            计算结果  
     */  
    private void handleReverseExplosion(MbomHeaderForExplosionPO header,  
                                        Map<Long, List<MbomLineForExplosionPO>> headerToLineMapping,  
                                        Map<String, MbomHeaderForExplosionPO> headerMaterialMapping,  
                                        List<MbomReverseExplosionDTO> resultList) {  
        List<MbomReverseExplosionDTO> currentList = Collections.synchronizedList(new ArrayList<>());  
        // 封装顶层  
        MbomExplosionNodeDTO topNode = new MbomExplosionNodeDTO(header, 0);  
        // 处理子节点  
        List<MbomLineForExplosionPO> lines = headerToLineMapping.getOrDefault(header.getId(), null);  
        if (!CollectionUtils.isEmpty(lines)) {  
            for (MbomLineForExplosionPO line : lines) {  
                List<String> currentPath = Collections.synchronizedList(new ArrayList<>());  
                currentPath.add(topNode.getMaterialCode());  
                traverseReversePathResult(topNode, line, currentPath, new ArrayList<>(), new ArrayList<>(),  
                        headerToLineMapping, headerMaterialMapping, currentList);  
            }  
        }  
        if (!CollectionUtils.isEmpty(currentList)) {  
            resultList.addAll(currentList);  
        }  
  
    }  
  
    /**  
     * ✅ 递归逆向展阶（获取节点、路径等信息）  
     *  
     * @param rootNode           顶层节点  
     * @param currentChildLine   当前处理的子节点的MBOM明细  
     * @param currentPath        当前节点路径  
     * @param currentBomIds      当前节点所有的BOM ID  
     * @param currentTimeRanges  当前节点的生效、失效时间范围  
     * @param topToLeftMapping   顶层MBOM ID 所映射关联出来的叶子节点  
     * @param topMaterialMapping 顶层MBOM 品号所映射关联出的品号信息  
     * @param result             结果  
     */  
    private void traverseReversePathResult(MbomExplosionNodeDTO rootNode, MbomLineForExplosionPO currentChildLine,  
                                           List<String> currentPath, List<Long> currentBomIds, List<MbomReverseExplosionDTO.TimeRange> currentTimeRanges,  
                                           Map<Long, List<MbomLineForExplosionPO>> topToLeftMapping,  
                                           Map<String, MbomHeaderForExplosionPO> topMaterialMapping,  
                                           List<MbomReverseExplosionDTO> result) {  
        String childMaterialCode = currentChildLine.getMaterialCode();  
        currentPath.add(childMaterialCode);  
        currentBomIds.add(currentChildLine.getHeaderId());  
        currentTimeRanges.add(new MbomReverseExplosionDTO.TimeRange(currentChildLine.getEffectiveFrom(), currentChildLine.getEffectiveTo()));  
        // 判断是否可以继续往下展阶  
        MbomHeaderForExplosionPO header = topMaterialMapping.get(childMaterialCode);  
        if (header != null) {  
            // 保存中间节点。例如 A->B->C，这里将对 B 进行保存（保存的路径是 A->B）  
            saveReversePath(currentChildLine, new ArrayList<>(currentPath), new ArrayList<>(currentBomIds),  
                    new ArrayList<>(currentTimeRanges), topMaterialMapping, result);  
            // 查询当前节点的下级节点  
            List<MbomLineForExplosionPO> childLines = topToLeftMapping.get(header.getId());  
            if (!CollectionUtils.isEmpty(childLines)) {  
                for (MbomLineForExplosionPO childLine : childLines) {  
                    MbomExplosionNodeDTO node = new MbomExplosionNodeDTO(childLine, rootNode.getLevel() + 1);  
                    traverseReversePathResult(node, childLine, currentPath, currentBomIds, currentTimeRanges,  
                            topToLeftMapping, topMaterialMapping, result);  
                }  
            }  
        } else {  
            // 叶子  
            saveReversePath(currentChildLine, new ArrayList<>(currentPath), new ArrayList<>(currentBomIds),  
                    new ArrayList<>(currentTimeRanges), topMaterialMapping, result);  
        }  
        // 路径回溯  
        currentPath.remove(currentPath.size() - 1);  
        currentBomIds.remove(currentBomIds.size() - 1);  
        currentTimeRanges.remove(currentTimeRanges.size() - 1);  
    }  
  
    /**  
     * ✅ 保存逆向展阶的各层级节点  
     *  
     * @param currentMaterial    当前所处理的元件  
     * @param fullPath           当前元件正向展阶的完整路径  
     * @param sourceBomIds       当前元件正向展阶的bom id  
     * @param timeRanges         当前元件的生效、失效时间范围  
     * @param topMaterialMapping 顶层物料映射关系  
     * @param result             结果  
     */  
    private void saveReversePath(MbomLineForExplosionPO currentMaterial, List<String> fullPath, List<Long> sourceBomIds,  
                                 List<MbomReverseExplosionDTO.TimeRange> timeRanges,  
                                 Map<String, MbomHeaderForExplosionPO> topMaterialMapping,  
                                 List<MbomReverseExplosionDTO> result) {  
        MbomReverseExplosionDTO.TimeRange pathTime = MbomReverseExplosionDTO.TimeRange.calcPathTime(timeRanges);  
        MbomReverseExplosionDTO path = new MbomReverseExplosionDTO();  
        path.setId(snowflakeIdWorker.nextId());  
        path.setLeafCode(currentMaterial.getMaterialCode());  
        path.setLeafName(currentMaterial.getMaterialName());  
        path.setLeafSpecs(currentMaterial.getMaterialSpecs());  
        path.setFullPath(fullPath);  
        path.setLevelCount(fullPath.size() - 1);  
        path.setEffectiveFrom(pathTime.getFrom());  
        path.setEffectiveTo(pathTime.getTo());  
        path.setLayerEffectiveInfo(timeRanges);  
        path.setSourceBomIds(sourceBomIds);  
        // 顶层  
        String topCode = fullPath.get(0);  
        MbomHeaderForExplosionPO topMaterial = topMaterialMapping.get(topCode);  
        path.setTopCode(topCode);  
        if (Objects.nonNull(topMaterial)) {  
            path.setTopName(topMaterial.getProductName());  
            path.setTopSpecs(topMaterial.getProductSpecs());  
            path.setTopVehicle(topMaterial.getProductVehicle());  
        }  
        // 次顶层  
        if (fullPath.size() > 2) {  
            path.setSubTopCode(fullPath.get(1));  
        }  
        result.add(path);  
    }  
  
    @Override  
    public List<String> calculateFinalPartApplicability(List<MbomReverseExplosionDTO> calcReverseList) {  
        if (CollectionUtils.isEmpty(calcReverseList)) {  
            return Collections.emptyList();  
        }  
        log.info(">>>>>>>> 开始执行MBOM零件适用车型最终表计算 (优化版) ... ...");  
        // 查询车辆下线信息  
        Map<String, LocalDateTime> vehicleOfflineMap = mdmMesVehicleOfflineService.getItemOfflineMap();  
        // 构建出子件与顶层主件之间的映射关系  
        Map<String, List<MbomReverseExplosionDTO>> reverseBomGrouped = calcReverseList.stream()  
                .collect(Collectors.groupingBy(k ->  
                        String.join(SystemConstants.SHORT_BAR,  
                                Objects.isNull(k.getLeafCode()) ? SystemConstants.EMPTY : k.getLeafCode(),  
                                Objects.isNull(k.getTopCode()) ? SystemConstants.EMPTY : k.getTopCode(),  
                                Objects.isNull(k.getSubTopCode()) ? SystemConstants.EMPTY : k.getSubTopCode())));  
        List<Map<String, List<MbomReverseExplosionDTO>>> calcPartitions = MapUtils.partitionMap(reverseBomGrouped, SystemConstants.CPU_CORE_NUMBER);  
        LocalDateTime currentTime = LocalDateTime.now();  
        List<CompletableFuture<List<String>>> calcFutures = calcPartitions.stream()  
                .map(p ->  
                        CompletableFuture.supplyAsync(() ->  
                                handleCalcFinalPartApplicability(p, currentTime, vehicleOfflineMap), computePool))  
                .collect(Collectors.toList());  
        return calcFutures.stream()  
                .map(CompletableFuture::join)  
                .filter(Objects::nonNull)  
                .flatMap(List::stream)  
                .collect(Collectors.toList());  
    }  
  
    /**  
     * 计算零件适用车型最终表  
     *  
     * @param currentReverseList 当前处理的MBOM逆向展阶计算结果  
     * @param currentTime        处理时间  
     * @param vehicleOfflineMap  车辆下线信息  
     * @return 计算结果 -- csv结构  
     */  
    private List<String> handleCalcFinalPartApplicability(Map<String, List<MbomReverseExplosionDTO>> currentReverseList,  
                                                          LocalDateTime currentTime,  
                                                          Map<String, LocalDateTime> vehicleOfflineMap) {  
        List<String> resultList = Lists.newArrayList();  
        LocalDate currentDate = currentTime.toLocalDate();  
        for (Map.Entry<String, List<MbomReverseExplosionDTO>> entry : currentReverseList.entrySet()) {  
            // 相同零件、主件、半成品件的 BOM 逆向展阶集合  
            List<MbomReverseExplosionDTO> values = entry.getValue();  
            BomStatusEnum[] bomStatusEnums = new BomStatusEnum[values.size()];  
            for (int i = 0; i < values.size(); i++) {  
                MbomReverseExplosionDTO part = values.get(i);  
                LocalDate effectiveFrom = part.getEffectiveFrom();  
                LocalDate effectiveTo = part.getEffectiveTo();  
                if (!effectiveFrom.isBefore(effectiveTo)) {  
                    bomStatusEnums[i] = BomStatusEnum.INACTIVE;  
                } else {  
                    if (!currentDate.isBefore(effectiveFrom) && currentDate.isBefore(effectiveTo)) {  
                        bomStatusEnums[i] = BomStatusEnum.ACTIVE;  
                    } else if (currentDate.isAfter(effectiveTo)) {  
                        bomStatusEnums[i] = BomStatusEnum.EXPIRED;  
                    } else if (currentDate.isBefore(effectiveFrom)) {  
                        bomStatusEnums[i] = BomStatusEnum.PENDING;  
                    }  
                }  
            }  
            BomStatusUtils.BomStatusResult bomStatusResult = BomStatusUtils.determineStatus(bomStatusEnums);  
            MbomReverseExplosionDTO dto = values.get(bomStatusResult.getIndex());  
            // 生成csv  
            resultList.add(toFinalCsvLine(dto, bomStatusResult.getStatus(), currentTime, vehicleOfflineMap));  
        }  
        return resultList;  
    }  
  
    /**  
     * 生成零件适用车型最终表的CSV文件中每一行数据（字段之间使用逗号分隔）  
     *  
     * @param reverse           每一行原始数据  
     * @param status            零件对应的状态  
     * @param currentTime       计算生成时间  
     * @param vehicleOfflineMap 车辆下线信息  
     * @return 拼接、格式化后的每一行数据  
     */  
    private String toFinalCsvLine(MbomReverseExplosionDTO reverse, BomStatusEnum status,  
                                  LocalDateTime currentTime, Map<String, LocalDateTime> vehicleOfflineMap) {  
        String topCode = reverse.getTopCode();  
        String subTopCode = reverse.getSubTopCode();  
        StringJoiner joiner = new StringJoiner(SystemConstants.COMMA);  
        joiner.add(escapeCsvField(String.valueOf(snowflakeIdWorker.nextId())));  
        joiner.add(escapeCsvField(reverse.getLeafCode()));  
        joiner.add(escapeCsvField(reverse.getLeafName()));  
        joiner.add(escapeCsvField(reverse.getLeafSpecs()));  
        joiner.add(escapeCsvField(reverse.getTopCode()));  
        joiner.add(escapeCsvField(reverse.getTopName()));  
        joiner.add(escapeCsvField(reverse.getTopSpecs()));  
        joiner.add(escapeCsvField(reverse.getSubTopCode()));  
        joiner.add(escapeCsvField(reverse.getTopVehicle()));  
        // 车辆下线信息  
        LocalDateTime topOfflineTime = vehicleOfflineMap.getOrDefault(topCode, null);  
        LocalDateTime subOfflineTime = vehicleOfflineMap.getOrDefault(subTopCode, null);  
        if (topOfflineTime != null || subOfflineTime != null) {  
            LocalDateTime firstOfflineTime = topOfflineTime != null ? topOfflineTime : subOfflineTime;  
            joiner.add(escapeCsvField("1"));  
            joiner.add(escapeCsvField(firstOfflineTime.toString()));  
        } else {  
            joiner.add(escapeCsvField("0"));  
            joiner.add(escapeCsvField(null));  
        }  
        joiner.add(escapeCsvField(String.valueOf(status.getCode())));  
        joiner.add(escapeCsvField(currentTime.toString()));  
        return joiner.toString();  
    }  
  
    /**  
     * ✅ 转义CSV字段  
     * - 如果字段为null，则返回空字符串""  
     * - 如果字段包含：逗号、双引号，换行(\n)，回车(\r)，则用双引号包裹，并将内部双引号转义为两个双引号  
     */  
    private String escapeCsvField(String value) {  
        if (value == null) {  
            return ""; // NULL 字段写为空（可被 LOAD DATA 识别为 NULL）  
        }  
  
        // 检查是否包含需要转义的字符  
        boolean needsQuotes = value.indexOf(',') >= 0 ||  
                value.indexOf('"') >= 0 ||  
                value.indexOf('\n') >= 0 ||  
                value.indexOf('\r') >= 0;  
  
        if (!needsQuotes) {  
            return value;  
        }  
  
        // 转义双引号: " → ""  
        StringBuilder escaped = new StringBuilder(value.length() + 10);  
        escaped.append('"');  
        for (int i = 0; i < value.length(); i++) {  
            char c = value.charAt(i);  
            if (c == '"') {  
                escaped.append("\"\""); // 转义  
            } else {  
                escaped.append(c);  
            }  
        }  
        escaped.append('"');  
        return escaped.toString();  
    }  
  
    @Override  
    public Long generateMiddleCsvAndLoadData(List<MbomReverseExplosionDTO> calcReverseList) {  
        if (CollectionUtils.isEmpty(calcReverseList)) {  
            return 0L;  
        }  
        log.info(">>>>>>>> 开始执行MBOM逆向展阶中间表生成CSV文件并导入到数据库操作 (优化版) ... ...");  
        // 生成CSV文件并存储到系统临时目录及OSS  
        List<List<MbomReverseExplosionDTO>> csvGenPartitions = CollectionUtils.partitionIntoN(calcReverseList, 16);  
        List<CompletableFuture<String>> fileFutures = IntStream.range(0, csvGenPartitions.size())  
                .mapToObj(n -> {  
                    List<MbomReverseExplosionDTO> chunk = csvGenPartitions.get(n);  
                    return CompletableFuture.supplyAsync(() -> handleGenMiddleCsvToOss(n, chunk), ioPool);  
                })  
                .collect(Collectors.toList());  
        // 等待所有上传任务执行完成后，组合成一个结果列表，统一进行load data入库操作  
        List<String> ossFilePaths = fileFutures.stream()  
                .map(CompletableFuture::join)  
                .collect(Collectors.toList());  
        if (CollectionUtils.isEmpty(ossFilePaths)) {  
            return 0L;  
        }  
        // 清空数据库  
        tmpMbomReverseExplosionService.cleanAllData();  
        // 重新导入数据  
        long totalDataSize = 0L;  
        for (String filePath : ossFilePaths) {  
            Long uploadRows = tmpMbomReverseExplosionService.loadOssCsvFileToDb(filePath);  
            if (Objects.nonNull(uploadRows)) {  
                totalDataSize += uploadRows;  
            }  
        }  
        return totalDataSize;  
    }  
  
    /**  
     * ✅ 生成CSV文件，并上传到OSS  
     *     * @return OSS文件路径  
     */  
    private String handleGenMiddleCsvToOss(int chunkNumber, List<MbomReverseExplosionDTO> csvContents) {  
        String fileName = "middle_table_" + chunkNumber + ".csv";  
        String ossObjectKey = "/mbom_reverse_explosion/" + fileName;  
        File localFile = new File(SystemConstants.TMPDIR, fileName);  
        try {  
            if (!localFile.getParentFile().exists()) {  
                //noinspection ResultOfMethodCallIgnored  
                localFile.getParentFile().mkdirs();  
            }  
            int count = 0;  
            try (BufferedWriter writer = new BufferedWriter(  
                    new OutputStreamWriter(  
                            Files.newOutputStream(localFile.toPath()), StandardCharsets.UTF_8))) {  
                for (MbomReverseExplosionDTO dto : csvContents) {  
                    if (Objects.nonNull(dto)) {  
                        writer.write(toMiddleCsvLine(dto));  
                        writer.newLine();  
                        count++;  
                    }  
                }  
                writer.flush();  
  
                log.info(">>>>>>>>>>>>>>>> 线程 {} 完成中间表CSV本地化临时存储，文件路径为 {}",  
                        Thread.currentThread().getName(), localFile.getAbsoluteFile());  
            }  
            // 上传oss  
            String ossTargetPath = aliyunOssService.chunkUploadCsvByFile(localFile, ossObjectKey);  
            log.info(">>>>>>>>>>>>>>>> 线程 {} 完成中间表CSV上传OSS任务，OSS文件路径为 {}",  
                    Thread.currentThread().getName(), ossTargetPath);  
            return ossTargetPath;  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        }  
    }  
  
    /**  
     * ✅ 生成MBOM逆向展阶计算中间表的CSV文件中每一行数据（字段之间使用逗号分隔）  
     *  
     * @param calcResult 每一行原始数据  
     * @return 拼接、格式化后的每一行数据  
     */  
    private String toMiddleCsvLine(MbomReverseExplosionDTO calcResult) {  
        StringJoiner joiner = new StringJoiner(SystemConstants.COMMA);  
        joiner.add(escapeCsvField(String.valueOf(calcResult.getId())));  
        joiner.add(escapeCsvField(calcResult.getLeafCode()));  
        joiner.add(escapeCsvField(calcResult.getLeafName()));  
        joiner.add(escapeCsvField(calcResult.getLeafSpecs()));  
        if (!CollectionUtils.isEmpty(calcResult.getFullPath())) {  
            joiner.add(escapeCsvField(JSON.toJSONString(calcResult.getFullPath())));  
            joiner.add(escapeCsvField(String.join(SystemConstants.COMMA, calcResult.getFullPath())));  
        } else {  
            joiner.add(escapeCsvField(null));  
            joiner.add(escapeCsvField(null));  
        }  
        joiner.add(escapeCsvField(String.valueOf(calcResult.getLevelCount())));  
        joiner.add(escapeCsvField(calcResult.getTopCode()));  
        joiner.add(escapeCsvField(calcResult.getTopName()));  
        joiner.add(escapeCsvField(calcResult.getTopSpecs()));  
        joiner.add(escapeCsvField(calcResult.getTopVehicle()));  
        joiner.add(escapeCsvField(calcResult.getSubTopCode()));  
        joiner.add(escapeCsvField(calcResult.getEffectiveFrom().toString()));  
        joiner.add(escapeCsvField(calcResult.getEffectiveTo().toString()));  
        joiner.add(escapeCsvField(CollectionUtils.isEmpty(calcResult.getLayerEffectiveInfo()) ? null : JSON.toJSONString(calcResult.getLayerEffectiveInfo())));  
        joiner.add(escapeCsvField(CollectionUtils.isEmpty(calcResult.getSourceBomIds()) ? null : JSON.toJSONString(calcResult.getSourceBomIds())));  
        return joiner.toString();  
    }  
  
    @Override  
    public Long generateFinalCsvAndLoadData(List<String> csvContentList) {  
        if (CollectionUtils.isEmpty(csvContentList)) {  
            return 0L;  
        }  
        log.info(">>>>>>>> 开始执行零件适用车型最终表生成CSV文件并导入到数据库操作 (优化版) ... ...");  
        // 生成CVS文件并存储到系统临时目录及OSS  
        List<List<String>> csvGenPartitions = CollectionUtils.partitionIntoN(csvContentList, 16);  
        List<CompletableFuture<String>> fileFutures = IntStream.range(0, csvGenPartitions.size())  
                .mapToObj(n -> {  
                    List<String> chunk = csvGenPartitions.get(n);  
                    return CompletableFuture.supplyAsync(() -> handleGenFinalCsvToOss(n, chunk), ioPool);  
                })  
                .collect(Collectors.toList());  
        // 等待所有上传任务执行完成后，组合成一个结果列表，统一进行load data入库操作  
        List<String> ossFilePaths = fileFutures.stream()  
                .map(CompletableFuture::join)  
                .collect(Collectors.toList());  
        if (CollectionUtils.isEmpty(ossFilePaths)) {  
            return 0L;  
        }  
        // 清空数据库  
        mbomPartTopApplicabilityService.cleanAllData();  
        // 重新导入数据  
        long totalDataSize = 0L;  
        for (String filePath : ossFilePaths) {  
            Long uploadRows = mbomPartTopApplicabilityService.loadOssCsvFileToDb(filePath);  
            if (Objects.nonNull(uploadRows)) {  
                totalDataSize += uploadRows;  
            }  
        }  
        return totalDataSize;  
    }  
  
    /**  
     * 生成最终表CSV文件，并上传到OSS  
     *     * @param chunkNumber 块号  
     * @param csvContents CSV文件内容  
     * @return OSS文件路径  
     */  
    private String handleGenFinalCsvToOss(int chunkNumber, List<String> csvContents) {  
        String fileName = "final_table_" + chunkNumber + ".csv";  
        String ossObjectKey = "/mbom_part_top_applicability/" + fileName;  
        File localFile = new File(SystemConstants.TMPDIR, fileName);  
        try {  
            if (!localFile.getParentFile().exists()) {  
                //noinspection ResultOfMethodCallIgnored  
                localFile.getParentFile().mkdirs();  
            }  
            int count = 0;  
            try (BufferedWriter writer = new BufferedWriter(  
                    new OutputStreamWriter(  
                            Files.newOutputStream(localFile.toPath()), StandardCharsets.UTF_8))) {  
                for (String perRow : csvContents) {  
                    if (StringUtils.isNotEmpty(perRow)) {  
                        writer.write(perRow);  
                        writer.newLine();  
                        count++;  
                    }  
                }  
                writer.flush();  
                log.info(">>>>>>>>>>>>>>>> 线程 {} 完成最终表CSV本地化存储任务，文件路径为 {}",  
                        Thread.currentThread().getName(), localFile.getAbsoluteFile());  
            }  
            // 上传oss  
            String ossTargetPath = aliyunOssService.chunkUploadCsvByFile(localFile, ossObjectKey);  
            log.info(">>>>>>>>>>>>>>>> 线程 {} 完成最终表CSV上传OSS任务，OSS文件路径为 {}",  
                    Thread.currentThread().getName(), ossTargetPath);  
            return ossTargetPath;  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        }  
    }  
  
}
```

- 基础服务
```java
public class MdmMesVehicleOfflineServiceImpl  
        extends ServiceImpl<MdmMesVehicleOfflineMapper, MdmMesVehicleOffline>  
        implements MdmMesVehicleOfflineService {  
  
    @Autowired  
    private MdmMesVehicleOfflineMapper mdmMesVehicleOfflineMapper;  
  
    @Override  
    public List<VehicleOfflineDTO> getVehicleOfflineAllList() {  
        return mdmMesVehicleOfflineMapper.selectVehicleOfflineAllList();  
    }  
  
    @Override  
    public Map<String, LocalDateTime> getFinishedItemOfflineMap() {  
        List<VehicleOfflineDTO> vehicleOfflineAllList = this.getVehicleOfflineAllList();  
        if (CollectionUtils.isEmpty(vehicleOfflineAllList)) {  
            return Collections.emptyMap();  
        }  
        Map<String, LocalDateTime> finishedItemOfflineMap = Maps.newHashMap();  
        for (VehicleOfflineDTO dto : vehicleOfflineAllList) {  
            if (StringUtils.isNotEmpty(dto.getFinishedItemCode())) {  
                finishedItemOfflineMap.put(dto.getFinishedItemCode(), dto.getFirstOfflineTime());  
            }  
        }  
        return finishedItemOfflineMap;  
    }  
  
    @Override  
    public Map<String, LocalDateTime> getSemiItemOfflineMap() {  
        List<VehicleOfflineDTO> vehicleOfflineAllList = this.getVehicleOfflineAllList();  
        if (CollectionUtils.isEmpty(vehicleOfflineAllList)) {  
            return Collections.emptyMap();  
        }  
        Map<String, LocalDateTime> semiItemOfflineMap = Maps.newHashMap();  
        for (VehicleOfflineDTO dto : vehicleOfflineAllList) {  
            if (StringUtils.isNotEmpty(dto.getSemiFinishedItemCode())) {  
                semiItemOfflineMap.put(dto.getSemiFinishedItemCode(), dto.getFirstOfflineTime());  
            }  
        }  
        return semiItemOfflineMap;  
    }  
  
    @Override  
    public Map<String, LocalDateTime> getItemOfflineMap() {  
        Map<String, LocalDateTime> itemOfflineMap = Maps.newHashMap();  
        Map<String, LocalDateTime> finished = this.getFinishedItemOfflineMap();  
        Map<String, LocalDateTime> semi = this.getSemiItemOfflineMap();  
        if (!CollectionUtils.isEmpty(semi)) {  
            itemOfflineMap.putAll(semi);  
        }  
        if (!CollectionUtils.isEmpty(finished)) {  
            itemOfflineMap.putAll(finished);  
        }  
        return itemOfflineMap;  
    }  
}

public class TmpMbomReverseExplosionServiceImpl  
        extends ServiceImpl<TmpMbomReverseExplosionMapper, TmpMbomReverseExplosion>  
        implements TmpMbomReverseExplosionService {  
  
    @Autowired  
    private SqlSessionFactory sqlSessionFactory;  
    @Autowired  
    private TmpMbomReverseExplosionMapper tmpMbomReverseExplosionMapper;  
    @Autowired  
    private DataSource dataSource;  
    @Autowired  
    private JdbcTemplate jdbcTemplate;  
    @Autowired  
    private AliyunOssService aliyunOssService;  
  
    @Autowired  
    private SnowflakeIdWorker snowflakeIdWorker;  
  
    @Override  
    public void cleanAllData() {  
        tmpMbomReverseExplosionMapper.cleanAllData();  
    } 
  
    @Override  
    public Long loadOssCsvFileToDb(String ossFilePath) {  
        String ossUrl = aliyunOssService.getLoadDataOssUrl(ossFilePath);  
        String sql = String.format("LOAD DATA\n" +  
                        "    /*+ PARALLEL(2) direct(true, 0) */\n" +  
                        "    REMOTE_OSS INFILE\n" +  
                        "    '%s'\n" +  
                        "    IGNORE\n" +  
                        "    INTO TABLE tmp_mbom_reverse_explosion\n" +  
                        "    FIELDS TERMINATED BY ',' ENCLOSED BY '\"'\n" +  
                        "    LINES STARTING BY '' TERMINATED BY '\\n'\n" +  
                        "    (id, leaf_code, leaf_name, leaf_specs, full_path, full_path_str, level_count, top_code, top_name, top_specs,\n" +  
                        "         top_vehicle, sub_top_code, effective_from, effective_to, layer_effective_info, source_bom_ids)",  
                ossUrl  
        );  
        return jdbcTemplate.execute((StatementCallback<Long>) stmt -> {  
            stmt.execute(sql);  
            long rows = stmt.getUpdateCount();  
            log.info("Load Data 返回影响行数: {}", rows);  
            return rows;  
        });  
    }  
}
```

- 组件服务
```java
public class AliyunOssService {  
  
    @Autowired  
    private OSS ossClient;  
    @Autowired  
    private AliyunOssProperties ossProperties;  
    
    public String uploadCsvByFile(File file, String targetPath) {  
        String finalTargetPath = ossProperties.getPrefix() + targetPath;  
        // 上传请求对象  
        PutObjectRequest putObjectRequest = new PutObjectRequest(ossProperties.getBucketName(), finalTargetPath, file);  
        // 设置元数据  
        ObjectMetadata metadata = new ObjectMetadata();  
        metadata.setContentType("text/csv");  
        putObjectRequest.setMetadata(metadata);  
  
        PutObjectResult result = ossClient.putObject(putObjectRequest);  
        if (Objects.nonNull(result)) {  
            log.info("上传结果: {}", JSON.toJSONString(result));  
        }  
        return finalTargetPath;  
    }  
  
    public String chunkUploadCsvByFile(File file, String targetPath) {  
        String finalTargetPath = ossProperties.getPrefix() + targetPath;  
        // 分片上传请求  
        UploadFileRequest uploadFileRequest = new UploadFileRequest(ossProperties.getBucketName(), finalTargetPath);  
        // 设置元数据  
        ObjectMetadata metadata = new ObjectMetadata();  
        metadata.setContentType("text/csv");  
        metadata.setContentEncoding("UTF-8");  
        uploadFileRequest.setObjectMetadata(metadata);  
        // 设置上传的文件  
        uploadFileRequest.setUploadFile(file.getAbsolutePath());  
        // 设置分片大小（10MB）  
        uploadFileRequest.setPartSize(10 * 1024 * 1024);  
        // 并行上传线程数  
        uploadFileRequest.setTaskNum(3);  
  
        try {  
            // 上传  
            UploadFileResult result = ossClient.uploadFile(uploadFileRequest);  
            log.info("分片上传成功，结果: {}", JSON.toJSONString(result));  
            return finalTargetPath;  
        } catch (Throwable e) {  
            log.error("分片上传失败，文件: {}, 路径: {}", file.getName(), finalTargetPath, e);  
            throw new RuntimeException(e);  
        }  
    }  
  
    /**  
     * 读取指定路径下的文件内容  
     *  
     * @param targetPath 文件路径  
     * @return 读取结果  
     */  
    public <T> List<T> readObject(String targetPath, Class<T> clazz) {  
        String finalTargetPath = ossProperties.getPrefix() + targetPath;  
        try (OSSObject ossObject = ossClient.getObject(ossProperties.getBucketName(), finalTargetPath);  
             BufferedReader reader = new BufferedReader(  
                     new InputStreamReader(ossObject.getObjectContent(), StandardCharsets.UTF_8))) {  
  
            // 配置按列位置映射的策略  
            ColumnPositionMappingStrategy<T> strategy = new ColumnPositionMappingStrategy<>();  
            strategy.setType(clazz);  
  
            return new CsvToBeanBuilder<T>(reader)  
                    .withMappingStrategy(strategy)  
                    .withSeparator(',')  
                    .withQuoteChar('"')  
                    .withIgnoreLeadingWhiteSpace(true)  
                    .build()  
                    .parse();  
        } catch (Exception e) {  
            throw new RuntimeException("OSS读取失败: " + finalTargetPath, e);  
        }  
    }  
  
    /**  
     * 获取OSS协议URL  
     *     * @param filePath 文件路径  
     * @return 结果  
     */  
    public String getOssUrl(String filePath) {  
        return SystemConstants.OSS + ossProperties.getBucketName() + "/" + filePath;  
    }  
  
    /**  
     * 获取使用load data方式的oss路径  
     *  
     * @param filePath 文件路径  
     * @return 结果  
     */  
    public String getLoadDataOssUrl(String filePath) {  
        return String.format("%s?host=%s&access_id=%s&access_key=%s", getOssUrl(filePath), ossProperties.getEndpoint(), ossProperties.getAccessKeyId(), ossProperties.getAccessKeySecret());  
    }  
  
  
}
```

- 线程池
```java
@Configuration  
@EnableAsync  
public class AsyncAutoConfig {  
  
    @Bean("taskExecutor")  
    public Executor taskExecutor() {  
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();  
        executor.setCorePoolSize(Runtime.getRuntime().availableProcessors());  
        executor.setMaxPoolSize(2 * Runtime.getRuntime().availableProcessors());  
        executor.setQueueCapacity(1000);  
        executor.setThreadNamePrefix("async-");  
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());  
        executor.initialize();  
        return executor;  
    }  
  
    @Bean("computePool")  
    public Executor computePool() {  
        // 严格限制核心数，避免切换  
        int cores = Runtime.getRuntime().availableProcessors();  
        return new ThreadPoolExecutor(  
                cores,  
                cores,  
                0L,  
                TimeUnit.MILLISECONDS,  
                new LinkedBlockingQueue<>(500),  
                new NamedThreadFactory("CPU-Fixed-Pool"),  
                new ThreadPoolExecutor.CallerRunsPolicy()  
        );  
    }  
  
    @Bean("ioPool")  
    public Executor ioPool() {  
        // IO 池可以共用，处理所有耗时 IO        int cores = Runtime.getRuntime().availableProcessors();  
        return new ThreadPoolExecutor(  
                cores * 4,  
                cores * 4 * 2,  
                60L,  
                TimeUnit.SECONDS,  
                new LinkedBlockingQueue<>(2000),  
                new NamedThreadFactory("IO-Common-Pool")  
        );  
    }
}
```

