### Q001：如何设计一个支撑双 11 百万级 QPS 的削峰填谷架构？

- **简答**：采用“分层过滤 + MQ 异步”：前端验证码拉长流量，中间布隆过滤器和 Redis 预扣减过滤无效请求，后端 MQ 异步排队写入数据库。
    
- **深度解析**：
    
    核心是**漏斗模型**。100万请求进入，CDN 拦截 30%，验证码和限流拦截 40%，Redis 预减库存后再过滤 20%，最终进入 MQ 的只有几千个有效订单请求。数据库只需按照自身吞吐平滑消费 MQ，从而保证在高并发冲击下系统不挂。

### Q002：线上分库分表数据迁移，如何实现“不停机”平滑过渡？

- **简答**：采用“双写机制”：同步双写 + 异步历史数据迁移 + 数据校验一致性比对。
    
- **深度解析**：
    
    1. **同步双写**：应用同时向新旧库写数据（旧库为主，新库为辅）。
        
    2. **历史迁移**：通过离线任务（如 DataX）或监听 Binlog 将历史数据从旧库同步到新库。
        
    3. **数据校验**：不断比对新旧库差异，修复数据。
        
    4. **切读、切写**：校验一致后，先切读流量到新库，运行稳健后彻底关闭旧库。

### Q003：什么是“消息染色”？在全链路压测中如何应用？

- **简答**：在流量入口给请求打上特殊标识（如 `is_test=true`），标识随调用链全链路透传。
    
- **深度解析**： 压测流量进入系统后，标识会通过 HTTP Header、RPC 隐式参数和 MQ 属性传播。**处理逻辑**：中间件识别到“染色”后，自动将数据路由到影子库（Shadow DB）、影子缓存和影子 MQ 队列，从而实现**在生产环境压测但不影响真实业务数据**。

### Q004：热点账户高频扣款（如大 V 抢红包）如何解决数据库行锁瓶颈？

- **简答**：将“单点写入”转为“汇总写入”或“子账户并行”。
    
- **深度解析**：
    
    1. **内存预减**：在 Redis 中进行高频扣减，异步批量写回数据库。
        
    2. **汇总记账**：引入中间表，将 100 笔扣减请求聚合成 1 条 Update 语句。
        
    3. **子账户设计**：将一个热点账户拆分为 10 个子账户，随机路由扣款，分散行锁竞争。

### Q005：什么是“级联失效（雪崩）”？除了熔断还有哪些预防手段？

- **简答**：下游故障引发上游线程耗尽。手段包括：线程池隔离、超时控制、限流、自动降级。
    
- **深度解析**： **线程池隔离**（Bulkhead Pattern）：为不同服务分配独立的线程池，即使 A 服务挂了，也不会耗尽 B 服务的资源。配合**严格的超时时间**，确保请求不会长时间挂起。在极端情况下，直接开启**静态化降级**，返回兜底内容。

### Q006：如何设计一个支持“撤回”功能的 IM 聊天系统？

- **简答**：利用消息 ID 定位，下发“控制指令”覆盖原始消息状态。
    
- **深度解析**：
    
    1. 消息发送后在 DB 和客户端缓存记录。
        
    2. 撤回操作发送一条类型为 `REVOKE` 的指令消息。
        
    3. 接收端收到指令后，根据消息 ID 隐藏原内容，显示“对方撤回了一条消息”。 **架构细节**：需考虑离线消息重排，撤回指令必须在缓存中保留一定时间（如 2 分钟内）。

### Q007：跨微服务的“分布式事务”该如何选型？

- **简答**：强一致性选 Seata AT 模式；高并发最终一致性选 RocketMQ 事务消息或 Saga 模式。
    
- **深度解析**： 没有完美的分布式事务。**TCC** 性能好但代码侵入极大；**Saga** 适合长事务但需要写补偿逻辑；**事务消息**最解耦，适合绝大多数电商场景。原则：**能用最终一致性，就不用强一致性。**

### Q008：多级缓存（本地缓存 + 分布式缓存）的一致性如何保证？

- **简答**：利用 MQ 的广播模式或 Redis 的 Pub/Sub 来同步删除各节点的本地缓存。
    
- **深度解析**： 当数据库更新时，先更新 Redis，然后向 MQ 发送一个“失效通知”。所有业务服务器监听该 Topic，收到后清除自身的 JVM 本地缓存（如 Caffeine）。这样能保证本地缓存与分布式缓存的分钟级一致性。

### Q009：亿级短链接系统（TinyURL）如何生成不重复的短码？

- **简答**：分布式 ID 发号器 + 62 进制转换。
    
- **深度解析**：
    
    1. 利用 Snowflake 或 Redis 生成唯一的长整型数字。
        
    2. 将数字转换为 0-9、a-z、A-Z 的 62 进制字符串。
        
    3. 存储映射关系（短码 -> 长链接）到磁盘，并将热点映射存入缓存。 **防碰撞**：利用布隆过滤器快速判断短码是否存在。

### Q010：数据库慢查询治理的完整流程。

- **简答**：监控发现 -> 自动审计 -> 索引优化/SQL重写 -> 读写分离/分库分表。
    
- **深度解析**： 先通过 `slow_query_log` 定位，利用 `EXPLAIN` 分析执行计划。**核心治理**：禁止 Select *，避免深分页。对于无法优化的复杂报表查询，通过 Canal 同步数据到 **ES 或 ClickHouse** 进行异构查询。

### Q011：高性能任务调度：为什么 XXL-JOB 比传统 Quartz 更适合分布式环境？

- **简答**：Quartz 依赖数据库行锁控制集群，性能瓶颈明显且缺乏管理端；XXL-JOB 采用调度与执行分离的架构，支持分片广播，扩展性更强。
    
- **深度解析**： Quartz 在分布式下通过 `db_lock` 抢占触发器，在大规模任务（如万级/秒）时会导致数据库连接枯竭。XXL-JOB 的调度中心只负责心跳和任务分发，通过 **自研 RPC** 异步推送到执行器。执行器端可以利用 **时间轮（Timing Wheel）** 算法在内存中高效调度，支撑起千万级任务的平滑运行。

### Q012：如何设计一个通用的 API 幂等性 SDK？

- **简答**：核心逻辑是“唯一标识 + 状态记录”。利用 Redis 存储 `requestId` 状态，结合自定义注解和 AOP 实现对业务无侵入。
    
- **深度解析**： **通用流程**：1. 客户端预先获取 `Token`；2. 请求携带 `Token`；3. AOP 拦截器在 Redis 中执行 `SETNX`，状态标记为“处理中”；4. 业务执行完成，更新状态为“已完成”并存储结果；5. 若请求重复，直接返回已存储的结果。**架构关键**：需考虑 Redis 宕机的降级方案，以及“处理中”状态的合理超时机制。

### Q013：分布式锁 Redlock 算法在时钟偏移下的潜在风险是什么？

- **简答**：如果不同节点的系统时钟跳跃（Clock Jump），可能导致锁提前过期，从而导致多个节点同时持有锁。
    
- **深度解析**： Redlock 依赖大多数（Majority）节点的 TTL 确认。如果其中一个节点的时钟突然快了 10 秒，那么它持有的锁会由于“过期”被释放，随后其他客户端可能重新获取该锁。在极高要求的金融场景下，架构师通常倾向于使用 **Zookeeper/etcd** 等基于强一致性协议（Raft/Zab）的锁，而非依赖物理时钟的 Redis 方案。

### Q014：架构选型决策：什么时候选 MongoDB，什么时候选 Cassandra？

- **简答**：MongoDB 适合模型灵活、类 JSON 存储、且需要强一致性（主从）的场景；Cassandra 适合海量写入、多数据中心冗余、且追求高可用性（无主架构）的场景。
    
- **深度解析**： MongoDB 是 **Document-based**，查询功能极强（支持聚合框架）。Cassandra 是 **Column-family**，其数据模型基于 LSM 树，写入速度极快，且原生支持异地多活。**架构建议**：社交媒体 Timeline 或物联网传感器数据选 Cassandra；复杂业务系统的非结构化数据选 MongoDB。

### Q015：云原生环境下，如何优化 Java 微服务的“冷启动”时间？

- **简答**：镜像瘦身、JVM 参数预调优、以及使用 GraalVM 提前编译（AOT）。
    
- **深度解析**： Java 的启动延迟主要在于类加载和 JIT 热点编译。**方案**：1. **GraalVM**：将 Java 编译成二进制镜像，启动速度提升 10-50 倍；2. **AppCDS**：共享类元数据；3. **K8s 预取**：在 Pod 准备好之前进行预热。这在 **Serverless (FaaS)** 场景下是核心瓶颈。

### Q016：服务平滑下线（Graceful Shutdown）的完整流程。

- **简答**：先摘除注册中心流量，等待进行中的请求处理完成（设置优雅停机等待期），最后关闭应用。
    
- **深度解析**：
    
    1. 接收到 `SIGTERM` 信号；2. 实例向注册中心（Nacos/Consul）发送下线通知；3. 实例进入 `readiness` 不健康状态，负载均衡不再分发新流量；4. 进程等待 20-30s（确保旧请求处理完）；5. 释放数据库连接池、关闭线程池；6. `exit 0`。

### Q017：什么是“自动开关降级”？如何根据系统指标触发？

- **简答**：根据系统实时水位（CPU、延迟、错误率）自动关闭非核心功能。
    
- **深度解析**：
    
    通过 **Sentinel 或 Hystrix** 设置规则。例如：当核心网关的平均 RT（响应时间）超过 500ms 且持续 5s 时，自动切断“猜你喜欢”等非核心推荐服务的调用，返回静态兜底数据。这能防止系统发生整体雪崩。

### Q018：异地多活：单元化架构（Unitization）如何解决跨地域延迟？

- **简答**：将流量按用户 ID 分片，确保同一用户的读写操作在同一个地理“单元（Cell）”内闭环。
    
- **深度解析**： 跨城市的光纤延迟约为 30ms。如果 A 城市写 B 城市读，用户体验极差。**架构设计**：通过统一接入层（MSHA）计算 `hash(userId)`。用户 A 所有的订单、账户数据都落在上海单元，即使上海单元挂了，才通过全局元数据将其切到北京单元。数据中心之间通过 MQ 进行准实时备份。

### Q019：如何在不影响性能的前提下进行“库内脱敏”？

- **简答**：采用“透明加密”或在应用层使用加密组件，对敏感字段进行对称加密，同时保留脱敏后的明文摘要用于查询。
    
- **深度解析**： 对手机号、身份证号使用 `AES` 加密存储。为了支持查询，可以同时存储一个 `MD5(手机号)` 的索引字段。查询时先将输入转化成 MD5，通过索引匹配。这种“影子字段”策略既满足了合规性，又避免了全表扫描导致的性能灾难。

### Q020：架构师如何复盘一次线上事故？（5 Whys 深度分析）

- **简答**：不推诿、不责备。通过时间线还原事实，利用“5 Whys”追根溯源，制定可落地的“改进 Action”。
    
- **深度解析**： **事故复盘三部曲**：
    
    1. **What & When**：还原故障时间轴（何时报警、何时止血、何时恢复）；
        
    2. **Why**：连续追问 5 次为什么（为什么 OOM？因为内存泄漏；为什么内存泄漏？因为 ThreadLocal 没释放...）；
        
    3. **How**：改进 Action。必须包含“系统优化”、“监控补全”和“流程规范”，每一个 Action 都必须有明确的负责人和截止日期，防止同一类事故再次发生。