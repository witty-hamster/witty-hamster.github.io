## 一、Docker
### Q001：Docker 命令中 `EXPOSE` 和 `-p` 映射的区别是什么？

- **回答方式一（声明流）**：`EXPOSE` 是在 Dockerfile 里声明容器打算监听哪个端口，仅起说明作用；`-p` 是在启动时真正的将宿主机端口与容器端口打通。
    
- **回答方式二（动作流）**：`EXPOSE` 像是名片上印的电话，能不能打通不一定；`-p` 则是拉了一根实实在在的电话线连到你家里。

### Q002：Docker 的 Namespace 和 Cgroups 在内核层面起什么作用？

- **回答方式一（内核机制流）**：Namespace 负责环境隔离（PID、网络等），让容器觉得自己在独立系统；Cgroups 负责资源限制（CPU、内存），防止单个容器榨干宿主机。
    
- **回答方式二（合租管理流）**：Namespace 是合租房里的单间，你在里面干啥别人看不见；Cgroups 是限电器，你这间房只能用 500 瓦，超了就断电（OOM）。

### Q003：Docker 镜像的“层级存储”是如何通过 **Overlay2** 文件系统实现的？在生产环境下，你如何通过“多阶段构建”来优化镜像大小并提升安全性？

- **回答方式一（存储机制流）**：Overlay2 利用 `LowerDir`（只读层）和 `UpperDir`（读写层）进行合并挂载。修改文件时采用“写时复制”（Copy-on-Write）。多阶段构建（Multi-stage Build）允许在第一个容器内编译代码，仅将最终生成的二进制文件拷贝到第二个极其精简的运行环境镜像中（如 Alpine），从而大幅减少镜像体积，并移除了不必要的工具链，降低了被攻击的面。
    
- **回答方式二（制作逻辑流）**：镜像就像盖楼，一层叠一层。多阶段构建就像是“过河拆桥”：先在工地（编译环境）把零件造好，然后只把零件运进新房（运行环境），把重型机械和建筑废料全部丢掉。这样房子轻便，而且外人也没法利用你的建筑工具搞破坏。

---

## 二、K8s
### Q001：K8s 中 Deployment 和 Pod 的关系是什么？

- **回答方式一（层级流）**：Pod 是 K8s 的最小运行单元；Deployment 是控制器，负责管理 Pod 的版本、副本数和滚动更新。
    
- **回答方式二（管理流）**：Pod 是干活的工人；Deployment 是包工头。包工头负责看工人够不够（副本数），要不要换新人（更新），工人累死了包工头再招一个。

### Q002：K8s 容器的 `Liveness Probe`（存活探针）如果检查失败，会发生什么？它与 `Readiness Probe` 有什么区别？

- **回答方式一（运维流）**：`Liveness` 失败会导致 Pod 被重启；`Readiness` 失败仅会将 Pod 从 Service 的流量后端移除。简单说：`Liveness` 决定生死，`Readiness` 决定是否接活。
    
- **回答方式二（场景流）**：如果你病了，`Liveness` 发现后会直接把你拉去“重造”（重启 Pod）；`Readiness` 发现你病了，会让你先休息，不给你派活（切断流量），等你病好了再继续工作。

### Q003：在 K8s 调度中，同一个 Pod 内部的多个容器是如何实现网络和存储共享的？Sidecar 模式在微服务治理（如 Service Mesh）中解决了什么问题？

- **回答方式一（底层架构流）**：Pod 内所有容器共享同一个 **Network Namespace**（通过 Pause 容器实现），因此它们可以通过 `localhost` 直接通信。在存储上，通过定义 `Volumes` 并挂载到多个容器中实现共享。Sidecar 模式将治理逻辑（如限流、日志采集、安全拦截）从业务代码中剥离，交给独立的代理容器处理，实现了业务与基础设施的解耦。
    
- **回答方式二（生活类比流）**：Pod 就像一套“两居室”。里面的容器共用一个门牌号（IP）和厨房（存储卷）。Sidecar 就像是给业务容器配的“随身秘书”，业务员只管谈生意（写业务代码），秘书负责挡酒、记账和打车（监控、日志和安全），互不干扰。

### Q004：K8s 的 `request` 和 `limit` 参数在内核层面是如何映射的？当宿主机资源紧张时，K8s 是如何根据 QoS 等级进行 Pod 驱逐（Eviction）的？

- **回答方式一（系统调度流）**：`request` 对应 Cgroups 的 `cpu.shares`（权重），影响 CPU 的调度分配；`limit` 对应 `cpu.cfs_quota_us`（硬限），决定上限。K8s 将 Pod 分为三个 QoS 等级：**Guaranteed**（req=limit）、**Burstable**（req<limit）和 **BestEffort**（未设置）。资源耗尽时，会优先驱逐 BestEffort 和超出请求量的 Burstable Pod，最后才动 Guaranteed Pod。
    
- **回答方式二（资源配置流）**：`request` 是低保，`limit` 是上限。QoS 就像银行的客户分级：Guaranteed 是金卡贵宾，除非银行倒闭，否则不会赶你走；BestEffort 是蹭空调的，一旦大厅坐不下（资源紧缺），第一个被撵出去的就是你。

### Q005：请口述 ClusterIP 类型的 Service 是如何通过 `iptables` 或 `IPVS` 实现负载均衡的？相比之下 `IPVS` 为什么更适合大规模集群？

- **回答方式一（网络协议流）**：Service 本质是一个虚拟 IP。`iptables` 模式利用 NAT 规则进行转发，但规则是链式存储，O(n) 的遍历效率在大规模 Service 下会劣化。`IPVS` 基于内核哈希表实现，复杂度为 O(1)，且支持更丰富的调度算法（如最少连接），在高并发场景下更稳定且性能更好。
    
- **回答方式二（路由查找流）**：`iptables` 像是一张超长的清单，快递员（数据包）得从头看到尾才能找到目的地。而 `IPVS` 像是一个高效的索引目录，快递员直接查目录一秒定位，在大仓库（大集群）里效率优势极其明显。

### Q006：Deployment 进行滚动更新（Rolling Update）时，如何利用 `Readiness Probe`（就绪探针）保证业务不中断？

- **回答方式一（运维流程流）**：滚动更新会启动新版本 Pod。`Readiness Probe` 负责监测新 Pod 内部业务是否真正启动成功。只有探针返回成功，K8s 才会将流量切入新 Pod 并销毁旧 Pod。如果新 Pod 启动失败，滚动过程会停止，配合 `maxUnavailable` 参数，可以保证集群中始终有可用节点在提供服务。
    
- **回答方式二（平滑更替流）**：就像商场换扶梯。新扶梯装好后不能马上让人上，得先空转一会（就绪探针检查）。确定新电梯稳当了，才把旧电梯停掉，指引顾客走新的。如果新电梯空转时坏了，旧电梯就不停，防止顾客没电梯坐（业务中断）。

