
## 一、数据库

### Q001：数据库事务的四大特性（ACID）分别是什么？

- **回答方式一（学术流）**：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。
    
- **回答方式二（白话流）**：要么全做要么不做；逻辑要对；大家干活别互相干扰；做完了就得写死在硬盘上。

### Q002：MySQL 在 RR（可重复读）隔离级别下，是如何通过 Next-Key Lock 解决幻读问题的？

- **回答方式一（锁范围流）**：Next-Key Lock = Record Lock（行锁） + Gap Lock（间隙锁）。它不仅锁住索引记录，还锁住记录之间的间隙，防止其他事务在该范围内插入新数据，从而在逻辑上解决了幻读。
    
- **回答方式二（区域封锁流）**：不仅要把家里的门锁上（行锁），还要把家门口的路也封了（间隙锁）。这样别人不仅进不去你家，也没法在你家门口盖新房，你抬头看窗外永远还是原来的样子。

### Q003：MySQL 如果发生“深分页”查询（如 limit 1000000, 10），除了子查询优化，还有什么基于“延迟关联”的方法？

- **回答方式一（索引覆盖流）**：先通过覆盖索引只查出主键 ID（此时不需要回表，极快），再通过这些 ID 关联原表查询具体字段。这大大减少了引擎层扫描并丢弃无效数据页的 IO 开销。
    
- **回答方式二（找人效率流）**：不要让警察（数据库）去翻 100 万个人的详细档案（回表）只为了找第 100 万零一个。让他先翻名单（索引）数出那几个人的编号，然后再去档案柜里拿那几个人的详细档案。

### Q004：为什么 B+ 树索引 3 层就能撑起千万级数据？如何计算？

- **回答方式一（数据建模流）**：非叶子节点存键值和指针。假设页 16KB，指针+键值约 14B，一个节点可存 1100+ 指针。3 层树的叶子节点数超过 $1100^2$，按每行记录 1KB 算，总承载量可达 2000 万条左右。
    
- **回答方式二（几何倍增流）**：因为分叉极多，像一棵茂盛的树。每一层都能指引成千上万个方向。只要“路标”足够密，三步之内就能找到全中国任何一户人家。

---

## 二、缓存

### Q001：Redis 常用的五种数据类型及应用场景？

- **回答方式一（概括流）**：String（计数、缓存）、Hash（对象存储）、List（队列）、Set（去重、交集）、ZSet（排行榜）。
    
- **回答方式二（场景流）**：想存验证码用 String；存用户信息用 Hash；做点赞排名用 ZSet；做共同好友功能用 Set。

### Q002：Redis 单线程为什么快？什么操作会使其“变慢”？

- **回答方式一（系统瓶颈流）**：快在纯内存操作、IO 多路复用和无锁竞争。慢在**大 Key 操作**（如 `hgetall`）或耗时命令（`keys *`），这些会阻塞单线程 Event Loop，导致后续请求排队。
    
- **回答方式二（窗口服务流）**：工作人员手速极快且不用跟别人商量（无锁），所以快。但他最怕有人让他搬一块巨大的石头（大 Key），搬石头的时候，后面办小业务的人都得等着。

### Q003：释放 Redis 锁为什么要用 Lua 脚本？脑裂情况下如何保证锁安全？

- **回答方式一（原子性流）**：Lua 保证“校验身份”和“删除锁”原子化，防止误删他人的锁。脑裂可用 Redlock（过半成功）或业务层隔离令牌（Fencing Token）解决。
    
- **回答方式二（姓名贴流）**：撕掉锁前得先看上面的名字对不对，且这个动作必须一气呵成。预防脑裂就像投票，必须得到大多数服务器的同意。

### Q004：Redis 哨兵集群选举 Leader 时，如果票数一样或发生平票，底层逻辑是如何决策的？

- **回答方式一（随机超时流）**：Sentinel 采用 Raft 协议的思想。每个 Sentinel 都有一个随机的超时时间，谁先超时谁就发起投票请求。这种随机性极大地降低了多个节点同时发起投票导致平票的概率。
    
- **回答方式二（起床闹钟流）**：就像一屋子人睡觉（平票后）。每个人定个随机闹钟，谁先醒谁就是班长（Leader）。因为大家闹钟时间不一样，所以基本不会有人同时醒来抢班长。

### Q005：高并发场景下，如何设计一个百万级 TPS 的本地缓存与 Redis 多级缓存同步方案？

- **回答方式一（通知发布流）**：本地缓存（Caffeine）支撑极高 TPS。数据变更时，通过 Redis Pub/Sub 或 MQ 广播“失效事件”，各实例收到后清理本地缓存。这种方案牺牲了短暂的强一致性，换取了极高的查询吞吐量。
    
- **回答方式二（情报网流）**：总部（Redis）存总数据，各分部（本地缓存）存副本。一旦总部改了，发个电报（MQ）给各分部：“把原来的销毁了，来我这拿新的”。这样平时大家直接在自家门口拿情报，速度最快。

### Q006：在高并发下，如何解决 Redis 缓存与数据库的“双写一致性”问题？为什么不推荐用强一致性方案？

- **回答方式一（工程流）**：常用方案是“延迟双删”或“监听 Binlog 异步删除缓存”。强一致性需要分布式锁或 2PC，这会大幅拉低系统吞吐量，在互联网高并发场景下，通常追求“最终一致性”。
    
- **回答方式二（平衡流）**：没有绝对的同步，只有尽可能小的时差。你要追求绝对一致，系统就会慢得像蜗牛；通过异步删缓存，虽然有几百毫秒数据对不上，但能保住系统不挂。

---

## 三、中间件

### Q001：RocketMQ 如何实现本地事务与消息发送的原子性？

- **回答方式一（二阶段流）**：发“半消息”到 Broker（对消费者不可见）→ 执行本地事务 → 发 Commit/Rollback。Broker 没收到确认会回查事务状态，实现最终一致性。
    
- **回答方式二（合同草稿流）**：先给邮局寄草稿，邮局扣下。事办成了打个电话让邮局发，办砸了让邮局撕。邮局没接到电话会主动打给你问情况。

### Q002：RocketMQ 的消息过滤（Tag vs SQL92）是在哪一端完成的？为什么 SQL92 过滤会损耗性能？

- **回答方式一（服务端开销流）**：Tag 过滤通常在服务端简单匹配，性能高；SQL92 在服务端执行复杂的表达式解析。由于需要解压消息头并进行布尔运算，会占用大量的 Broker CPU，因此高并发下需慎用。
    
- **回答方式二（安检门流）**：Tag 像看衣服颜色，瞄一眼就行（性能好）；SQL92 像开箱检查并填表（逻辑复杂），安检员（Broker）动作慢了，后面排队的包裹就堆积了。

