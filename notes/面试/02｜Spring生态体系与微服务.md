## 一、Spring
### Q001：Spring Bean 的作用域（Scope）有哪些？默认是哪种？

- **回答方式一（官方流）**：常见的有 `singleton`（单例）、`prototype`（原型）、`request`、`session`。默认是 `singleton`，整个容器只有一个实例。
    
- **回答方式二（管理流）**：默认是“一夫一妻制”，你要多少次给你的都是同一个；原型是“多生多育”，每次问它要，它都给你克隆一个新的。

### Q002：Spring Bean 作用域中的 `singleton` 在多线程下是安全的吗？如果单例 Bean 注入了 `prototype` Bean，会有什么问题？

- **回答方式一（依赖生命周期流）**：不安全，单例 Bean 共享成员变量。由于单例 Bean 只在容器初始化时注入一次依赖，被注入的 `prototype` Bean 会由于闭包效应也变成“单例”。解决办法是使用 `ObjectProvider` 或 `@Lookup` 注解实现按需获取。
    
- **回答方式二（保质期类比流）**：就像冰箱（单例）里的牛奶（多例）。你虽然希望每次喝新鲜的，但由于牛奶一直放在同一个冰箱里，其实你每次拿出来的还是第一天放进去的那盒。必须用“动态贩卖机”（ObjectProvider）才能每次拿新的。

### Q003：`@Resource` 和 `@Autowired`注解有什么区别？

- **回答方式一（标准流）**：`@Autowired` 是 Spring 定义的，默认按类型（byType）注入；`@Resource` 是 J2EE 标准定义的，默认按名称（byName）注入。
    
- **回答方式二（来源流）**：一个是“亲儿子”（Spring 产），一个是“干儿子”（Java 规范产）。名字对不上时，`@Autowired` 配合 `@Qualifier` 用，而 `@Resource` 直接改 `name` 属性。

### Q004：Spring AOP 中 JDK 动态代理和 CGLIB 代理的底层实现有何区别？Spring 如何决定用哪种？

- **回答方式一（字节码流）**：JDK 代理利用反射机制生成一个实现代理接口的匿名类；CGLIB 利用 ASM 框架生成目标类的子类。如果目标类实现了接口，Spring 默认用 JDK；否则强制用 CGLIB。
    
- **回答方式二（继承流）**：JDK 代理是“找个替身”，前提是你得有个共同的祖宗（接口）；CGLIB 是“生个儿子”，直接继承你。如果你的类是 `final` 的（没法生儿子），CGLIB 就没招了。

### Q005：如何通过源码理解 `@EventListener` 与 Spring 容器启动过程的解耦？

- **回答方式一（发布订阅流）**：Spring 维护了一个 `ApplicationEventMulticaster`。当事件发布时，多播器会遍历已注册的监听器并调用。它利用了观察者模式，使得业务逻辑无需硬编码调用其他 Service。
    
- **回答方式二（广播站流）**：就像村里的广播（事件发布），各家各户（监听器）想听就听。广播站不用管谁在听，只要把消息喊出去就行，实现了解耦。
### Q006：Spring 容器如果遇到循环依赖，为什么构造器注入无法解决，而 Setter 注入可以？

- **回答方式一（实例化阶段流）**：构造器注入是在对象实例化过程中就需要依赖，此时对象尚未创建完成，无法放入三级缓存。Setter 注入是对象先实例化（毛坯房建好）后才填充属性，此时可以将半成品放入缓存供他人引用。
    
- **回答方式二（先鸡后蛋流）**：构造器注入要求“先结婚再买房”，没房结不了婚；Setter 注入是“先领证（实例化），等有了房（依赖）再搬进去（属性注入）”，领了证大家就知道你们是两口子了，流程能走下去。

### Q007：Spring 三级缓存如何解决循环依赖？为什么二级缓存不行？

- **回答方式一（生命周期流）**：一级存成品，二级存半成品，三级存 ObjectFactory。引入三级是为了支持 **AOP**。如果 Bean 需要被代理，三级缓存能保证其他 Bean 注入的是代理后的对象而非原始对象。如果只有二级缓存，在 AOP 场景下会注入错误的引用。
    
- **回答方式二（施工现场流）**：盖房子。一级是样板房，二级是刚建好的毛坯房，三级是建筑蓝图。如果不分二三级，你可能会把没装修的毛坯房当成样板房卖给了客户。

### Q008：Spring 事务失效的常见原因有哪些？同类内方法调用 `@Transactional` 为什么失效？

- **回答方式一（代理机制流）**：失效源于非 public 方法、异常被捕获或自调用。自调用（`this.method()`）不经过 Spring 产生的代理对象，无法触发 AOP 增强逻辑，因此事务不生效。
    
- **回答方式二（入口控制流）**：事务像个“正门”。只有通过代理对象这个正门进来，事务才会开启。如果你已经在屋里了，从卧室走到客厅是不经过正门的，所以没人给你开事务。

---

## 二、SpringBoot

### Q001：Spring Boot 的自动配置（Auto-Configuration）底层是如何通过 `Conditional` 注解实现按需加载的？

- **回答方式一（SPI扫描流）**：通过扫描 `spring.factories`（新版本为 `AutoConfiguration.imports`）加载配置类。利用 `@ConditionalOnClass` 等注解，在类加载阶段判断 classpath 是否存在特定 Jar 包，从而决定是否创建相关的 Bean。
    
- **回答方式二（智控开关流）**：就像智能家居。只有当你买回了灯泡（引入 Jar 包），墙上的开关（配置类）才起作用；如果没有灯泡，开关就自动隐藏，不会报错。




---

## 三、SpringCloud

### Q001：Spring Cloud 的负载均衡器如何处理“服务预热”？避免新节点启动后瞬间被大流量击垮。

- **回答方式一（权重动态算法流）**：在 LoadBalancer（如 Ribbon）中可以自定义权重策略。新启动节点会根据启动时间线性增加权重（如 5 分钟内权重从 0% 升至 100%），引导流量平滑切入，避免 JVM 刚启动时 JIT 编译尚未完成导致的响应变慢。
    
- **回答方式二（新兵入伍流）**：就像新兵上战场，不能一上来就让他冲最前面。先给他排轻活（小流量），看他适应了（JVM 热身好了），再慢慢把任务加满，防止他一上场就崩溃。

### Q002：Spring Cloud Gateway 的异步非阻塞模型相比 Zuul 1.x 有什么本质提升？

- **回答方式一（线程模型流）**：Zuul 1.x 基于 Servlet，一个请求占一个线程，并发高时线程池易爆。Gateway 基于 WebFlux 和 Netty，利用事件循环（Event Loop），少量线程配合 IO 多路复用即可处理海量连接。
    
- **回答方式二（餐厅经营流）**：Zuul 1.x 像老饭馆，一个客人配一个服务员，客人不点完菜服务员不能走；Gateway 像快餐店，一个柜员只负责点单发号，后厨做好了再叫号，柜员可以不停接单。

### Q003: Spring Cloud Gateway 抛弃了 Zuul 1.x 的 Servlet 模型，转而使用基于 Netty 的 WebFlux。这种改变是如何解决高并发下的“线程饥饿”问题的？

- **回答方式一（响应式编程流）**：Zuul 1.x 是“一请求一线程”模型，如果下游服务响应慢，线程会阻塞在等待上，导致线程池耗尽。Gateway 采用 Reactor 模型，基于事件驱动，少量的线程即可管理大量的连接（Channel）。当 IO 未准备好时，线程可以去处理其他任务，直到 IO 事件就绪再回调执行，极大地提升了系统的并发承载上限。
    
- **回答方式二（餐厅模式流）**：Zuul 1.x 是老餐馆，一个客人配一个服务员，客人不点完菜服务员就不能走。Gateway 是快餐店，一个柜员只负责点单（非阻塞），点完给个号，后厨做好了再叫号。这样柜员就不会被一个犹豫不决的客人占死，一个柜员能接待成百上千个客人。

### Q004：Eureka 在什么情况下会进入“自我保护模式”？相比之下，Nacos 为什么能支持在 CP 和 AP 模式之间切换？在分布式环境下，这两种选择分别对应了哪些业务诉求？

- **回答方式一（架构权衡流）**：Eureka 默认是 AP。当 15 分钟内超过 85% 的心跳丢失时，Eureka 会开启自我保护，不再剔除过期服务，以保证可用性。Nacos 默认是 AP（针对临时实例），但也支持 CP（针对持久实例，采用 Raft 协议）。选择 AP 适合对可用性要求极高的微服务，而 CP 适合对配置或元数据一致性极其敏感的金融场景。
    
- **回答方式二（容错思维流）**：Eureka 比较“宽容”，它认为网络抖动比服务宕机更常见，所以宁可留错也不删错。Nacos 比较“全能”，它提供了一个开关。如果你需要像银行存钱那样准确（一致性），就开 CP；如果你需要像看视频那样不能断（可用性），就开 AP。

### Q005：OpenFeign 默认使用的 HTTP 客户端是什么？在高并发场景下，直接使用默认配置会产生什么问题？如何通过集成连接池来优化它的吞吐量？

- **回答方式一（网络底层流）**：OpenFeign 默认使用 JDK 的 `HttpURLConnection`，它没有连接池，每次请求都要进行 TCP 三次握手和四次挥手，开销巨大。在高并发下，会产生大量的 `TIME_WAIT` 连接。优化手段是集成 `Apache HttpClient` 或 `OkHttp`，并合理配置 `MaxTotal` 和 `DefaultMaxPerRoute`，实现长连接复用，降低响应延迟。
    
- **回答方式二（性能调优流）**：默认的 Feign 像是一个一次性快递员，送一单签一次合同。在高并发下，签合同的时间比送货还长。集成连接池后，就像雇了一支专业的车队（连接池），车一直在路上跑，送完一单马上接下一单，省去了反复签合同（握手）的过程。

### Q006：在不重启应用的情况下，Spring Cloud 如何实现配置的动态刷新？为什么需要引入消息总线（Bus）？

- **回答方式一（事件驱动流）**：应用启动时会加载 `@RefreshScope` 标注的 Bean 的代理对象。当配置中心（如 Nacos）配置变更时，通过 Spring Cloud Bus（底层为 MQ）发送一个 `RefreshRemoteApplicationEvent` 广播。各节点接收到事件后，销毁旧的 Bean 并重新生成，利用代理模式在下次调用时切换到新配置。
    
- **回答方式二（实时更新流）**：就像公司下发新规定，总不能让大家离职再入职（重启）。配置中心是总部，Bus 消息总线是内部群。总部在群里喊一声“规则变了”，所有人收到消息后，自动擦掉旧笔记写上新的，整个过程业务不停。

---

## 四、微服务

### Q001：在高并发场景下，你会选择线程池隔离还是信号量隔离？两者的底层开销和适用场景有何不同？

- **回答方式一（隔离机制流）**：线程池隔离（Hystrix 默认）支持异步调用和超时控制，它通过独立的线程池将故障隔离，但会增加上下文切换的开销。信号量隔离（Sentinel 常用）仅限制并发数，不创建新线程，开销极小。信号量适合高频且响应极快的调用，而线程池适合有第三方依赖、响应时间不稳定的场景。
    
- **回答方式二（资源分配流）**：线程池隔离像是给每个部门独立配了车间和员工，一个车间着火了不影响别的部门，但管理费（开销）贵。信号量隔离像是共享办公区的工位，只限制进场人数，不额外配人。人多的时候能省钱，但一旦有人在工位上占着不走（请求超时），你很难强行把他踢出去。






